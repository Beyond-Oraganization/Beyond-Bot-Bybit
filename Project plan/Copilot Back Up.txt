// See https://aka.ms/new-console-template for more information
using System.Threading;
using Serilog;
using Bybit.Net;
using Bybit.Net.Clients;

Log.Logger = new LoggerConfiguration()
    .WriteTo.Console()
    .CreateLogger();

Log.Information("BeyondBot_Bybit started. Running 24/7...");

async Task Main()
{
    // Initialize Bybit client with your API credentials (replace with actual keys)
    var client = new BybitRestClient();
    client.SetApiCredentials("your-api-key", "your-api-secret"); // Required for placing orders

    bool orderPlaced = false; // Flag to place order only once for this example

    while (true)
    {
        try
        {
            // Placeholder for bot logic
            Log.Information($"Bot is running... {DateTime.Now}");

            // Example: Place a limit buy order for XAUT/USDT at price 4000 (quantity 0.01, adjust as needed)
            if (!orderPlaced)
            {
                var orderResult = await client.SpotApi.Trading.PlaceOrderAsync(
                    symbol: "XAUTUSDT",
                    side: Bybit.Net.Enums.OrderSide.Buy,
                    type: Bybit.Net.Enums.OrderType.Limit,
                    quantity: 0.01m, // Adjust quantity based on your balance
                    price: 4000m
                );

                if (orderResult.Success)
                {
                    Log.Information($"Limit buy order placed successfully: {orderResult.Data.Id}");
                    orderPlaced = true; // Prevent re-placing
                }
                else
                {
                    Log.Error($"Failed to place order: {orderResult.Error}");
                }
            }

            // Sleep for a short interval to avoid high CPU usage
            Thread.Sleep(1000); // 1 second, adjust as needed
        }
        catch (Exception ex)
        {
            Log.Error($"Error: {ex.Message}");
            // Optionally, add logging or recovery logic
        }
    }
}

// Call the async Main
await Main();

Log.Logger = new LoggerConfiguration()
    .WriteTo.Console()
    .CreateLogger();

Log.Information("BeyondBot_Bybit started. Running 24/7...");

while (true)
{
    try
    {
        // Placeholder for bot logic
        // Add your trading bot code here
        Log.Information($"Bot is running... {DateTime.Now}");
        //https://github.com/Beyond-Oraganization/Beyond-Bot-Bybit.git
        // Sleep for a short interval to avoid high CPU usage
        Thread.Sleep(1000); // 1 second, adjust as needed
    }
    catch (Exception ex)
    {
        Log.Error($"Error: {ex.Message}");
        // Optionally, add logging or recovery logic
    }
}









Summary of Adjustments
I have made the following changes based on your request:

Updated Database Schema: The Strategies table already uses StrategyData instead of Data to avoid SQL keyword conflicts.

Created Strategy Model Class: Added Strategy.cs with properties for ID, KLineID, and StrategyData, including constructors and XML documentation comments.

Enhanced MySQLController: Added comprehensive CRUD methods for Strategies (GetStrategies, InsertStrategy, UpdateStrategy, DeleteStrategy). Also added detailed XML documentation comments to all methods and the class for better code readability and IntelliSense support.

The project builds successfully with these updates.

*** Guide for Implementing Further Database Modifications ***
To modify your database schema and keep your code in sync, follow these steps:

1. Update the Database Schema
Edit DatabaseSchema.sql to add, remove, or modify tables/columns.
For example, to add a new column to Orders:
Run the updated SQL script against your MySQL database using MySQL Workbench, command line, or your preferred tool.
2. Update Model Classes
If adding/removing columns, update the corresponding C# class in Model.
Add new properties with appropriate data types (e.g., string for VARCHAR, decimal for DECIMAL).
Ensure classes are public and properties have getters/setters.
Update constructors as needed.
3. Update MySQLController Methods
Modify SELECT queries to include new columns.
Update INSERT/UPDATE statements to handle new parameters.
Use parameterized queries to prevent SQL injection.
Add new CRUD methods for new tables if needed.
4. Handle Data Type Mappings
MySQL DATETIME → C# DateTime
MySQL DECIMAL → C# decimal
MySQL VARCHAR → C# string
MySQL INT → C# int
Enums: Store as VARCHAR in DB, parse with Enum.Parse<T>() in code.
5. Best Practices
Always use using statements for database connections to ensure proper disposal.
Validate input data before database operations.
Consider adding error handling (try-catch) for database exceptions.
For large datasets, implement pagination or filtering in queries.
Update connection string in MySQLController if credentials change.
6. Testing
After changes, build the project and test CRUD operations.
Verify data integrity and relationships.
Check for any breaking changes in existing code.
This approach ensures your database and code remain synchronized as your project evolves. If you need help with specific modifications, provide details about the changes you want to make.

To rename the database table manually (from Strategies to StrategyCaches), follow these steps. This assumes you have access to your MySQL database (e.g., via MySQL Workbench, command line, or another client) and that the table exists in the BeyondBotDB database.

Manual Steps:
Connect to your MySQL database: Use your preferred MySQL client tool (e.g., MySQL Command Line Client, MySQL Workbench, or phpMyAdmin).

Select the database: Run the following SQL command to switch to the target database:

Rename the table: Execute the RENAME TABLE command to update the table name:

This command is idempotent (safe to run multiple times if the table already exists with the new name).
It preserves all data, indexes, and foreign key constraints.
Verify the change: After running the command, confirm the table was renamed by listing tables or querying the new table name:

Or check the structure:

How I Created the Migration Script:
I reviewed the original database schema in DatabaseSchema.sql, which defines the table as StrategyCaches.
Based on the code changes (renaming the class and updating references), I identified that existing databases might still have the old Strategies table name.
I generated a simple SQL script to perform the rename, ensuring it matches the new schema. This script is stored in Migration_Rename_Strategies.sql for easy execution.
If you encounter errors (e.g., table not found), ensure the database and table exist, and check your permissions. For production databases, back up data first. If you need to automate this in code, you could add it to your application's startup logic using the MySQL connector.